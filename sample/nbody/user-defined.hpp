class FileHeader{
public:
    PS::S64 n_body;
    PS::F64 time;
    PS::S32 readAscii(FILE * fp) {
		fscanf(fp, "%lf\n", &time);
		fscanf(fp, "%lld\n", &n_body);
		return n_body;
    }
    void writeAscii(FILE* fp) const {
	fprintf(fp, "%e\n", time);
	fprintf(fp, "%lld\n", n_body);
    }
};

class FPGrav{
public:
    PS::S64    id;
    PS::F64    mass;
    PS::F64vec pos;
    PS::F64vec vel;
    PS::F64vec acc;
    PS::F64    pot;    

    static PS::F64 eps;

    PS::F64vec getPos() const {
        return pos;
    }

    PS::F64 getCharge() const {
        return mass;
    }

    void copyFromFP(const FPGrav & fp){ 
        mass = fp.mass;
        pos  = fp.pos;
    }

    void copyFromForce(const FPGrav & force) {
        acc = force.acc;
        pot = force.pot;
    }

    void clear() {
        acc = 0.0;
        pot = 0.0;
    }

	void writeAscii(FILE* fp) const {
		fprintf(fp, "%lld\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n", 
                this->id, this->mass,
                this->pos.x, this->pos.y, this->pos.z,
                this->vel.x, this->vel.y, this->vel.z);
	}

	void readAscii(FILE* fp) {
		fscanf(fp, "%lld\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n", 
               &this->id, &this->mass,
               &this->pos.x, &this->pos.y, &this->pos.z,
               &this->vel.x, &this->vel.y, &this->vel.z);
	}

};

PS::F64 FPGrav::eps = 1.0/32.0;

#ifdef ENABLE_PHANTOM_GRAPE_X86

template <class TParticleJ>
struct CalcGravity{

    void operator () (const FPGrav * iptcl,
                      const PS::S32 ni,
                      const TParticleJ * jptcl,
                      const PS::S32 nj,
                      FPGrav * force) {

        const PS::S32 nipipe = ni;
        const PS::S32 njpipe = nj;
        PS::F64 (*xi)[3] = (PS::F64 (*)[3])malloc(sizeof(PS::F64) * nipipe * PS::DIMENSION);
        PS::F64 (*ai)[3] = (PS::F64 (*)[3])malloc(sizeof(PS::F64) * nipipe * PS::DIMENSION);
        PS::F64  *pi     = (PS::F64  *    )malloc(sizeof(PS::F64) * nipipe);
        PS::F64 (*xj)[3] = (PS::F64 (*)[3])malloc(sizeof(PS::F64) * njpipe * PS::DIMENSION);
        PS::F64  *mj     = (PS::F64  *    )malloc(sizeof(PS::F64) * njpipe);

        for(PS::S32 i = 0; i < ni; i++) {
            xi[i][0] = iptcl[i].pos[0];
            xi[i][1] = iptcl[i].pos[1];
            xi[i][2] = iptcl[i].pos[2];
            ai[i][0] = 0.0;
            ai[i][1] = 0.0;
            ai[i][2] = 0.0;
            pi[i]    = 0.0;
        }

        for(PS::S32 j = 0; j < nj; j++) {
            xj[j][0] = jptcl[j].pos[0];
            xj[j][1] = jptcl[j].pos[1];
            xj[j][2] = jptcl[j].pos[2];
            mj[j]    = jptcl[j].mass;
        }

#ifdef PARTICLE_SIMULATOR_THREAD_PARALLEL
        PS::S32 devid = omp_get_thread_num();
#else
        PS::S32 devid = 0;
#endif
        g5_set_xmjMC(devid, 0, nj, xj, mj);
        g5_set_nMC(devid, nj);
        g5_calculate_force_on_xMC(devid, xi, ai, pi, ni);

        for(PS::S32 i = 0; i < ni; i++) {
            force[i].acc[0] += ai[i][0];
            force[i].acc[1] += ai[i][1];
            force[i].acc[2] += ai[i][2];
            force[i].pot    -= pi[i];
        }

        free(xi);
        free(ai);
        free(pi);
        free(xj);
        free(mj);
    }
};

#else

#ifdef OpenCL
#include "OpenCLDevice.hpp"
typedef unsigned long long int uint64;

static bool cl_first = true;
const uint64 iplatform = 0;
const uint64 idevice   = 0;
const uint64 ik = 0;
static const uint64 n_opencldevice0 = 4;

std::vector<OpenCLDevice *> ov;
cl::Kernel ker[n_opencldevice0*2];
cl::Event ker_event[n_opencldevice0*2];
std::string kernel_options;
cl::Buffer b_xi, b_yi, b_zi;
cl::Buffer b_xj, b_yj, b_zj, b_mj;
cl::Buffer b_ax, b_ay, b_az, b_pt;

// This file automatically generated by template-converter
// DO NOT EDIT!

char kernel_n2_file[] =
"#define READONLY_P const * restrict \n"
"\n"
"__kernel\n"
"void \n"
"grav0(\n"
"      __global float READONLY_P xi_, \n"
"      __global float READONLY_P yi_, \n"
"      __global float READONLY_P zi_, \n"
"      __global float READONLY_P xj_, \n"
"      __global float READONLY_P yj_, \n"
"      __global float READONLY_P zj_, \n"
"      __global float READONLY_P mj_, \n"
"      __global float *ax, \n"
"      __global float *ay, \n"
"      __global float *az, \n"
"      __global float *pt,\n"
"      const int n, \n"
"      const float eps2\n"
"      )\n"
"{\n"
"  unsigned int g_xid = get_global_id(0);\n"
"  unsigned int g_yid = get_global_id(1);\n"
"  unsigned int g_w   = get_global_size(0);\n"
"  unsigned int gid   = g_yid*g_w + g_xid;\n"
"  unsigned int i = gid;\n"
"\n"
"  float xi = xi_[i];\n"
"  float yi = yi_[i];\n"
"  float zi = zi_[i];\n"
"  float e2 = eps2;\n"
"\n"
"  float a_x = 0.0f;\n"
"  float a_y = 0.0f;\n"
"  float a_z = 0.0f;\n"
"  float p_t = 0.0f;\n"
"\n"
"  for(unsigned int j = 0; j < n; j++) {\n"
"    float xj = xj_[j];\n"
"    float yj = yj_[j];\n"
"    float zj = zj_[j];\n"
"    float mj = mj_[j];\n"
"\n"
"    float dx, dy, dz;\n"
"    dx = xi - xj;\n"
"    dy = yi - yj;\n"
"    dz = zi - zj;\n"
"\n"
"    float r2 = dx*dx + dy*dy + dz*dz + e2;\n"
"//    float r1i = native_rsqrt(r2);\n"
"    float r1i = 1.0f/sqrt(r2);\n"
"    float r2i = r1i*r1i;\n"
"    float r1im = mj*r1i;\n"
"    float r3im = r1im*r2i;\n"
"\n"
"    a_x -= dx*r3im;\n"
"    a_y -= dy*r3im;\n"
"    a_z -= dz*r3im;\n"
"    p_t -= r1im;\n"
"  }\n"
"\n"
"  ax[i] = a_x;\n"
"  ay[i] = a_y;\n"
"  az[i] = a_z;\n"
"  pt[i] = p_t;\n"
"}\n";

template <class TParticleJ>
class CalcGravity {
public:
  CalcGravity() {
    if (cl_first) {
      try {
	ov.push_back(new OpenCLDevice(iplatform));    
	ov[0]->SetupContext(idevice);

	ov[0]->SetKernelOptions(kernel_options);
	ov[0]->BuildOpenCLKernels(kernel_n2_file);
	ker[0] = ov[0]->GetKernel("grav0");

	// read only buffers (HOST -> GPU)
	uint64 nall = 8192;
	b_xi = cl::Buffer(ov[0]->ctx, CL_MEM_READ_ONLY, nall*sizeof(cl_float));
	b_yi = cl::Buffer(ov[0]->ctx, CL_MEM_READ_ONLY, nall*sizeof(cl_float));
	b_zi = cl::Buffer(ov[0]->ctx, CL_MEM_READ_ONLY, nall*sizeof(cl_float));
	b_xj = cl::Buffer(ov[0]->ctx, CL_MEM_READ_ONLY, nall*sizeof(cl_float));
	b_yj = cl::Buffer(ov[0]->ctx, CL_MEM_READ_ONLY, nall*sizeof(cl_float));
	b_zj = cl::Buffer(ov[0]->ctx, CL_MEM_READ_ONLY, nall*sizeof(cl_float));
	b_mj = cl::Buffer(ov[0]->ctx, CL_MEM_READ_ONLY, nall*sizeof(cl_float));
	// output buffers (GPU -> HOST)
	b_ax = cl::Buffer(ov[0]->ctx, CL_MEM_WRITE_ONLY, nall*sizeof(cl_float));
	b_ay = cl::Buffer(ov[0]->ctx, CL_MEM_WRITE_ONLY, nall*sizeof(cl_float));
	b_az = cl::Buffer(ov[0]->ctx, CL_MEM_WRITE_ONLY, nall*sizeof(cl_float));
	b_pt = cl::Buffer(ov[0]->ctx, CL_MEM_WRITE_ONLY, nall*sizeof(cl_float));

	ker[ik].setArg(0,  b_xi);
	ker[ik].setArg(1,  b_yi);
	ker[ik].setArg(2,  b_zi);
	ker[ik].setArg(3,  b_xj);
	ker[ik].setArg(4,  b_yj);
	ker[ik].setArg(5,  b_zj);
	ker[ik].setArg(6,  b_mj);
	ker[ik].setArg(7,  b_ax);
	ker[ik].setArg(8,  b_ay);
	ker[ik].setArg(9,  b_az);
	ker[ik].setArg(10, b_pt);

	cl_first = false;
      }  catch( cl::Error e ) {
	std::cerr << e.what() << ":" << e.err() << "\n";
	exit(-1);
      }
    }
  }

  void operator () (const FPGrav * iptcl,
		    const PS::S32 ni,
		    const TParticleJ * jptcl,
		    const PS::S32 nj,
		    FPGrav * force) {

    float *tmp_xi = (float *)malloc(sizeof(float) * ni);
    float *tmp_yi = (float *)malloc(sizeof(float) * ni);
    float *tmp_zi = (float *)malloc(sizeof(float) * ni);
    float *tmp_ax = (float *)malloc(sizeof(float) * ni);
    float *tmp_ay = (float *)malloc(sizeof(float) * ni);
    float *tmp_az = (float *)malloc(sizeof(float) * ni);
    float *tmp_pt = (float *)malloc(sizeof(float) * ni);
    float *tmp_xj = (float *)malloc(sizeof(float) * nj);
    float *tmp_yj = (float *)malloc(sizeof(float) * nj);
    float *tmp_zj = (float *)malloc(sizeof(float) * nj);
    float *tmp_mj = (float *)malloc(sizeof(float) * nj);

    for(PS::S32 i = 0; i < ni; i++) {
      tmp_xi[i] = iptcl[i].pos[0];
      tmp_yi[i] = iptcl[i].pos[1];
      tmp_zi[i] = iptcl[i].pos[2];
    }

    for(PS::S32 j = 0; j < nj; j++) {
      tmp_xj[j] = jptcl[j].pos[0];
      tmp_yj[j] = jptcl[j].pos[1];
      tmp_zj[j] = jptcl[j].pos[2];
      tmp_mj[j] = jptcl[j].mass;
    }

    ker[ik].setArg(11, (int)nj);
    ker[ik].setArg(12, (float)(FPGrav::eps * FPGrav::eps));

    cl_bool flag = CL_FALSE; 

    ov[0]->q.enqueueWriteBuffer(b_xi, flag, 0, ni*sizeof(cl_float), tmp_xi);
    ov[0]->q.enqueueWriteBuffer(b_yi, flag, 0, ni*sizeof(cl_float), tmp_yi);
    ov[0]->q.enqueueWriteBuffer(b_zi, flag, 0, ni*sizeof(cl_float), tmp_zi);
    ov[0]->q.enqueueWriteBuffer(b_xj, flag, 0, nj*sizeof(cl_float), tmp_xj);
    ov[0]->q.enqueueWriteBuffer(b_yj, flag, 0, nj*sizeof(cl_float), tmp_yj);
    ov[0]->q.enqueueWriteBuffer(b_zj, flag, 0, nj*sizeof(cl_float), tmp_zj);
    ov[0]->q.enqueueWriteBuffer(b_mj, flag, 0, nj*sizeof(cl_float), tmp_mj);
      
    ov[0]->q.enqueueNDRangeKernel(ker[ik], cl::NullRange, 
				  cl::NDRange(ni), cl::NullRange,
				  NULL, &ker_event[0]);
    ov[0]->q.flush();
    ker_event[0].wait();

    flag = CL_TRUE;
    ov[0]->q.enqueueReadBuffer(b_ax, flag, 0, ni*sizeof(cl_float), tmp_ax);
    ov[0]->q.enqueueReadBuffer(b_ay, flag, 0, ni*sizeof(cl_float), tmp_ay);
    ov[0]->q.enqueueReadBuffer(b_az, flag, 0, ni*sizeof(cl_float), tmp_az);
    ov[0]->q.enqueueReadBuffer(b_pt, flag, 0, ni*sizeof(cl_float), tmp_pt);

    for(PS::S32 i = 0; i < ni; i++) {
      force[i].acc[0] += tmp_ax[i];
      force[i].acc[1] += tmp_ay[i];
      force[i].acc[2] += tmp_az[i];
      force[i].pot    += tmp_pt[i];
    }

    free(tmp_xi);
    free(tmp_yi);
    free(tmp_zi);
    free(tmp_ax);
    free(tmp_ay);
    free(tmp_az);
    free(tmp_pt);
    free(tmp_xj);
    free(tmp_yj);
    free(tmp_zj);
    free(tmp_mj);
  }
};

#else
template <class TParticleJ>
struct CalcGravity{
    void operator () (const FPGrav * ep_i,
                      const PS::S32 n_ip,
                      const TParticleJ * ep_j,
                      const PS::S32 n_jp,
                      FPGrav * force) {

        PS::F64 eps2 = FPGrav::eps * FPGrav::eps;
        for(PS::S32 i = 0; i < n_ip; i++){
            PS::F64vec xi = ep_i[i].pos;
            PS::F64vec ai = 0.0;
            PS::F64 poti = 0.0;
            for(PS::S32 j = 0; j < n_jp; j++){
                PS::F64vec rij    = xi - ep_j[j].pos;
                PS::F64    r3_inv = rij * rij + eps2;
                PS::F64    r_inv  = 1.0/sqrt(r3_inv);
                r3_inv  = r_inv * r_inv;
                r_inv  *= ep_j[j].mass;
                r3_inv *= r_inv;
                ai     -= r3_inv * rij;
                poti   -= r_inv;
            }
            force[i].acc += ai;
            force[i].pot += poti;
        }
    }
};
#endif

#endif
